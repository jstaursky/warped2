import numpy as np
import networkx as nx
import community as comm # install from python-louvain
from collections import OrderedDict
from operator import itemgetter

"""
Split the group into at-most n partitions with approximately equals sum of values
using best-fit algorithm
"""
def balancedPartitioner(group, n):
    result  = [[] for i in range(n)]
    sums    = {i:0 for i in range(n)}
    min_sum = 0
    for entry in group:
        for i in sums:
            if min_sum == sums[i]:
                result[i].append(entry[1])
                break
        sums[i] += entry[0]
        min_sum  = min(sums.values())
    return result

"""
Split the partition into sub-partitions based on the dictionary generated by the dendrogram
"""
def subPartitioner(partition, partition_dict):
    sub_partition_dict = {}
    for node in partition:
        sub_partition_dict.setdefault(partition_dict[node], []).append(node)
    sub_partitions = []
    for sub_partition_id, nodes in sub_partition_dict.iteritems():
        sub_partitions.append(nodes)
    return sub_partitions

"""
Build a undirected weighted graph using data inside data_file and partition it at multiple levels 
using the Louvain algorithm. Returns the node-level partitions.
"""
def partition(data_file, n):

    # Read the data and build the undirected weighted graph
    data    = np.loadtxt(data_file, dtype=np.intc, delimiter = ",", skiprows=1, usecols=(0,1,2))
    node_x  = [x[0] for x in data]
    node_y  = [x[1] for x in data]
    weight  = [int(x[2]) for x in data]
    G = nx.Graph()
    for i in np.arange(len(data)):
        G.add_node(int(node_x[i]))
        G.add_edge(int(node_x[i]),int(node_y[i]), weight=int(weight[i])) 

    # Build the dendrogram and read partitions at different levels
    dendo = comm.generate_dendrogram(G)

    louvain_partitions = {}
    level = len(dendo)-1
    while level >= 0:
        louvain_partitions = {}
        louvain_partitions = comm.partition_at_level(dendo, level)
        if len(set(louvain_partitions.values())) >= n:
            break
        level -= 1

    louvain_subpartitions = {}
    if level > 0:
        louvain_subpartitions = comm.partition_at_level(dendo, level-1)

    # Order partitions based on partition id, then order based on partition size
    group = {}
    for node_id, partition_id in louvain_partitions.iteritems() :
        group.setdefault(partition_id, []).append(node_id)

    ordered_group = []
    for k in sorted(group, key=lambda k: len(group[k])) :
        ordered_group.append( (len(group[k]), k) )

    # Build the optimal partitions
    partitions = []
    for entry in balancedPartitioner(ordered_group, n):
        nodes = []
        for partition_id in entry:
            nodes.extend(group[partition_id])
        if louvain_subpartitions:
            sub_partitions = subPartitioner(nodes, louvain_subpartitions)
            partitions.append(sub_partitions)
        else:
            partitions.append(nodes)

    #return partitions
    return "hello"
