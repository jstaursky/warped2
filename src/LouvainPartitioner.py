#!/usr/bin/env python

import numpy as np
import networkx as nx
import community as comm

"""
Split the group into at-most n partitions with approximately equals sum of values
using best-fit algorithm
"""
def balancedPartitioner(group, n):
    # n should always be > 1
    result  = [[] for i in range(n)]
    sums    = {i:0 for i in range(n)}
    min_sum = 0
    for entry in group:
        for i in sums:
            if min_sum == sums[i]:
                result[i].append(entry[1])
                break
        sums[i] += entry[0]
        min_sum  = min(sums.values())
    return result

"""
Split the partition into sub-partitions based on the dictionary generated by the dendrogram
"""
def subPartitioner(partition, partition_dict):
    sub_partition_dict = {}
    for node in partition:
        sub_partition_dict.setdefault(partition_dict[node], []).append(node)
    sub_partitions = []
    for sub_partition_id, nodes in sub_partition_dict.iteritems():
        sub_partitions.append(nodes)
    return sub_partitions

"""
Build a undirected weighted graph using data inside data_file and partition it at multiple
levels using the Louvain algorithm. Return a string with inter-node partition delimiter is
'-', intra-node partition delimiter is ';' and each value is delimited by ','.
"""
def partition(data_file, n):
    # Read the data and build the undirected weighted graph
    data    = np.loadtxt(data_file, dtype=np.intc, delimiter = ",", skiprows=1, usecols=(0,1,2))
    node_x  = [x[0] for x in data]
    node_y  = [x[1] for x in data]
    weight  = [int(x[2]) for x in data]
    G = nx.Graph()
    for i in np.arange(len(data)):
        G.add_node(int(node_x[i]))
        G.add_edge(int(node_x[i]),int(node_y[i]), weight=int(weight[i])) 

    # Build the dendrogram and read partitions at different levels
    dendo = comm.generate_dendrogram(G)

    louvain_partitions = {}
    level = len(dendo)-1
    while level >= 0:
        louvain_partitions = comm.partition_at_level(dendo, level)
        if len(set(louvain_partitions.values())) >= n:
            break
        level -= 1

    # Order partitions based on partition id
    group = {}
    for node_id, partition_id in louvain_partitions.iteritems() :
        group.setdefault(partition_id, []).append(node_id)

    # When only intra-node partitioning is required
    if n == 1:
        pattern = []
        for partition_id in group:
            pattern.append(",".join(str(p) for p in group[partition_id]))
        return ";".join(p for p in pattern)

    # When there are multiple nodes involved
    # Order based on partition size
    ordered_group = []
    for k in sorted(group, key=lambda k: len(group[k])) :
        ordered_group.append((len(group[k]), k))

    # Find a sub-partition
    louvain_subpartitions = {}
    if level > 0:
        louvain_subpartitions = comm.partition_at_level(dendo, level-1)

    # Build the optimal partitions
    # Pack everything into a string using delimiters
    partitions = []
    for entry in balancedPartitioner(ordered_group, n):
        nodes = []
        for partition_id in entry:
            nodes.extend(group[partition_id])
        if louvain_subpartitions:
            sub_partitions = subPartitioner(nodes, louvain_subpartitions)
            partitions.append(";".join(",".join(map(str, sp)) for sp in sub_partitions))
        else:
            partitions.append(",".join(str(n) for n in nodes))

    return "-".join(p for p in partitions)

